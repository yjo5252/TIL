# Operating System
### 1. 컴퓨터 시스템을 계층적으로 묘사할 때 운영체제의 위치는? 유틸리티 - 하드웨어 사이   
  *  하드웨어 - 운영체제 - 유틸리티 - 응용 프로그램 - 사용자 
### 2. 운영체제 
  * 다중 사용자와 다중 응용 프로그램 환경 하에서 자원의 현재 상태를 파악하고, 자원 분배를 위한 스케줄링을 담당한다. 
  * 운영체제는 스스로 어떤 유용한 기능도 수행하지 않고, 다른 응용 프로그램이 유용한 작업을 할 수 있도록 환경을 마련한다. 
  * CPU, 메모리 공간(메모리 할당, 회수 관리), 기억장치, 입출력 장치, 중앙처리장치의 시간, 파일(생성,석제,변경,유지) 등의 자원을 관리한다. 
  * 데이터를 관리하고 데이터 및 자원의 공유 기능을 제공한다. 
  * 사용자 프로그램을 제어한다 => 프로세스 스케줄링 및 동기화 관리 담당, 프로세스 생성과 제거, 시작과 정지, 메시지 전달 등의 기능 담당한다. 
  
  
### 3. 운영체제의 기능 
  * 자원의 스케줄링 기능을 제공한다. 
  * 자원 보호 기능을 제공한다. 
  * 사용자와 시스템 간의 편리한 인터페이스를 제공한다. 

### 4. 운영체제의 목적
  * 처리 능력의 향상 
  * 사용 가능도 증대
  * 신뢰도 향상 

### 5. 운영체제의 성능을 판단하는 요소 
  * 처리 능력 (Throughput): 일정 시간 내에 시스템이 처리하는 일의 양
  * 신뢰도 (Reliability): 시스템이 주어진 문제를 정확하게 해결하는 정도 
  * 사용 가능도 (Availability): 한정된 컴퓨터 시스템 내의 자원을 여러 사용자가 요구할 때 어느정도 신속하고 충분히 지원해 줄 수 있는 지의 정도이다. 
    * 이는 사용 가능한 하드웨어 자원의 수나 다중 프로그래밍 정도 드으이 요소사 좌우하는 것
    * 같은 종류의 시스템 자원수가 많을 경우에는 이것이 높아질 수 있다. 
  * 반환 시간 (Turn Around Time): 시스템에 작업을 의뢰한 시간부터 처리가 완료될 때까지 걸린 시간 
  
  
## Windows 
### 1. Windows 주요 특징 
* Plug and Play (PnP)
: 윈도우에서 사용자가 사용하기 원하는 하드웨어를 시스템에 부착하면 자동으로 인식하여 동작하게 해주는 기능
* Object Linking and Embedding (OLE)
: 개체(Object)를 현재 작성중인 문서에 자유롭게 연결(Linking) 하거나 삽입(Embedding) 하여 편집할 수 있게 하는 기능이다. 
* 선점형 멀티태스킹 (Preemptive Multi-Tasking) 
: 응용 프로그램 간의 자료 공유.  동시에 여러 개의 프로그램을 실행하는 멀티태스킹을 한다. 운영체제가 각 작업의 CPU 이용시간을 제어하여 프로그램 실행 중 문제가 발생하면 해당 프로그램을 종료시키고 모든 시스템 자원을 반환하는 방식을 말한다. 
* 그래픽 사용자 인터페이스 (GUI; Graphic User Interface) 
: 초보자도 쉽게 사용할 수 있는 그래픽 사용자 인터페이스 (GUI)를 채용한다. 

* 참고) 멀티 프로그래밍 : 컴퓨터의 윈도우 창에 여러 윈도우를 열어 놓고 작업하는 것을 기억장치 처리 방법으로 이르는 말. 

## Unix / Linux / MacOS

### UNIX 의 특징 
* 트리 구조 파일 시스템
* 대화식 운영체제 
* 높은 이식성. 
* 높은 장치 프로세스 간의 호환성.
* Mutli-User는 지원하며 Multi-Tasking 을 지원한다. 

### UNIX 명령어를 백그라운드로 수행시킬 때 장점 
* 수행중인 명령문이 끝나기 전에 다른 명령문을 줄 수 있다. 
* 포그라운드, 백그라운드 작업

### UNIX에서 커널에 대한 설명
* UNIX 시스템의 중심부에 해당한다. 
* **자원관리**하는 역할을 수행한다. (프로세스 관리, 기억장치 관리 담당한다.)
* 컴퓨터 부팅 시 주기억장치에 적재되어 상주하면서 실행된다. 

### UNIX 구성요소 
* pipe : 
    * UNIX에서 두 프로세스를 연결하여 프로세스 간의 통신을 가능하게 한다. 
    * 한 프로세스의 출력이 다른 프로세스의 입력으로 사용된다.
* shell: 
    * 시스템과 사용자 간의 인터페이스를 담당한다. 
    * **명령어 해석**하는 역할 수행한다. 
    * 사용자의 명령어를 인식하여 프로그램을 호출한다. 

* 시스템 호출 
    * UNIX 시스템에서 사용자와 운영체제 서비스를 연결해주는 인터페이스이다. 
    * 상위 수준의 소프트웨어가 커널의 기능을 이용할 수 있도록 지원해준다. 

## 기억장치 관리 
### 기억장치 관리 전략 
* Fetch (반입) 전략 
    * 프로그램/데이터를 주기억 장치로 가져오는 시기를 결정하는 전략.
* Placement (배치) 전략 
    * 새로 들어온 프로그램과 데이터를 주기억장치 내의 어디에 놓을지 결정하기 위한 주기억장치 배치 전략: 최적(Best Fit), 최악(Worst Fit), 최초(First Fit) 
    * First Fit: 프로그램이 들어갈 수 있는 크기 중 처음 영역 
    * Worst Fit : 단편화가 가장 많이 남아서 최악인 영역 = 사용되지 않는 영역이 가장 큰 영역 
    * Best Fit : 단편화가 가장 적어 최적인 영역
* Replacement (교체) 전략 
    * FIFO (Fisrt In First Out)
    * LRU (Least Recently Used)
    * LFU (Least Frequently Used)


* 참고) paging 전략은 가상 기억장치에서 사용되는 기법이다. 


## 주기억 장치 할당 기법 
* 고정 분할 기억장치 할당 
    *  주기억장치의 사용자 영역을 일정 수의 고정된 크기로 분할하여 준비상태 큐에서 준비 중인 프로그램을 각 영역에 할당하여 수행중인 기법
    * 내부조각 (Internal Fragmentation) 현상이 발생한다. 
    * 주기억장치와 보조기억장치 간에 데이터 이동이 자주 발생하지 않는다. 
    * 프로그램이 주어진 분할 안에 다 들어갈 수 없는 경우가 생길 수 있다. 
    * 프로그램이 실행되기 위해서는 그 전체가 주기억장치에 위치해야 한다. 

* 연속 로딩 기법 (다중 분할 할당 기법)
    * 기억공간 관리 중 고정 분할 할당과 동적 분할 할당으로 나누어 관리되는 기법이다. 

## 가상 기억장치 구현 기법  / 페이지 교체 알고리즘 
### 가상기억장치 
* 연속 배달방식에서의 기억 장소 단편화 문제를 적극적으로 해결할 수 있다. 
* 기억장치의 이용률과 다중 프로그래밍의 효율을 높일 수 있다. 
* 가상기억장치의 일반적인 구현 방법: 페이징 기법  & 세그멘테이션 기법 
* 사용 목적: 주기억장치보다 큰 프로그램을 수행하기 위해서. 
* 동적 주소 변환 (DAT) 기법은 프로세스가 수행될 때 가상주소를 실주소로 바꾸어준다. 
* 블록 : 크기가 고정된 블록 페이지, 크기가 변할 수 있는 블록 세그먼트 
 

### 페이징 기법 
* 동적 주소 변환을 위해 페이지 맵 테이블(Page map table)이 필요하다. 
* 프로그램을 **일정한 크기**로 나눈 단위 = 페이지. 
* 이 페이지를 블록으로 사용하는 기법이다. 
* 내부 단편화가 발생할 수 있다. 
* 페이지 교체 기법: FIFO, LRU, LFU, NUR 
    * NUR (Not Used Recently) : 매 페이지마다 두 개의 하드웨어 비트 (참조 비트, 변형 비트)가 필요하다. 


### 세그멘테이션 기법
* 하나의 작업을 **크기가 각각 다른** 여러 논리적인 단위로 나누어 사용한다. 
* 외부 단편화가 발생할 수 있다. 
* 각 세그먼트는 고유한 이름과 크기를 갖는다. 
* 프로그램을 일정한 크기로 나눈 단위 = 세그먼트 
* 기억장치 보호키가 필요하다. 
* 한 프로세스의 세그먼트들은 동시에 모두 기억장치 내에 있을 필요가 없으며, 연속적일 필요도 없다. 


### 스케줄링 
* 가상기억장치에서 주기억장치로 페이지를 옮겨 넣을 때 주소를 조정해줘야 한다. 






