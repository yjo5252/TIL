# 동적 프로그래밍 (Dynamic Programming)

* 하나의 문제에 중복이 굉장히 많이 발생하는 경우에 적용하는 방법이다. 
* 추가적이 메모리 공간이 필요하다!! 

###  피보나치 수열의 재귀 프로그램 문제 
* 많은 중복 호출이 발생 
* 전항과 전전항을 더하는 것이다. 무리수 황금비율 (1.618)을 따라간다.

## 중복호출을 해결하는 방법 
* 구현되는 방법들 (!! = 코테에서 이 접근법을 모르면 못푸는 문제 있다 ㅋㅋㅋ )
    * 비재귀 프로그램 (forward) 사용 : O(N).  
        * (재귀프로그램이었으면 중복호출이어서 비효율적이었을 것이다.)
    * 메모리에 호출된 결과값을 저장하고 다음 호출 때 해당 값을 사용 : O(N) !! 
    * 수학적 접근방법 : O(1) !! 
    * 행렬식 사용 : 분할정복을 사용한다. O(logN) !!   
  * 구현 코드는 sudo code 임! 

### 비재귀 프로그램 
* 반복문을 사용하는 해결법 

```Python
def fib(n):
    f = [0, 1]
    for _ in range(2, n+1, 2):  
        f[0] += f[1]
        f[1] += f[0]
    return f[n%2]
```

### 동적프로그래밍을 이용한 재귀프로그래밍 
* 메모리 공간을 사용한 해결방법 
```python
dp = [-1]*(n+1) # 피보나치 수열을 저장할  공간 확보 
dp[0], dp[1] = 0, 1
def fib(n):
    if dp[n] != -1 : return dp[n]
    return dp[n] = fib(n-1) + fib(n-2)
```

### 수학적 접근 방법
* 황금비율수를 이용한 접근 방법 
```python
Sqrt5 = 2.236068 
Phi = 1.618034
def fib(n)
    return int((Phi**n - (1-Phi) **n)/Sqrt5 + 0.5)

```
### 행렬을 이용한 접근방법 
* 두 개의 항목을 벡터로 묶어서 행렬 계산 
* [a(n+1), a(n+2)] = [0, 1]
```python 
def mul(a,b): 
    m11, m12 = a[0]*b[0] + a[1]*b[2], a[0]*b[1] + a[1]*b[3]
    m21, m22 = a[2]*b[0] + a[3]*b[2], a[2]*b[1] + a[3]*b[3]
    return (m11, m12, m21, m22) 

def fib(n): 
    n -= 1
    a, b = (1, 1, 1, 0), (1, 0, 1, 0)
    while n > 0: 
        if n%2 == 1: b = mul(a, b)
        a = mul(a, a)
        n //= 2
    return b[2]

```

## 응용
### 2xn 타일링 
```python
""" 
" -------------------------------------------------------------------------------------
"	DP  - 2xn 타일링 : 2xn 공간에 2x1 타일과 2x2 타일로 채우는 방법의 수를 구하시오 
" 	- by Grace Jo
" 	 - created at : 2021-07-13 
" -------------------------------------------------------------------------------------
"""

"""
점화식을 구하면 해결 가능하다. 
답: a(n) = a(n-1) + 2*a(n-2), with a(0) = 0, a(1) = 1; 
T(0) = 1
T(1) = 1 
T(2) = T(1) * 2 + 1 = 3
T(3) = T(2) * 2 - 1 = 5
T(4) = T(3) * 2 + 1 = 11 

^^ : T(n) = T(n-1) * 2 + (-1)^(n/2)

T(n) = A * 2 ^ n + B * (-1) ^ n
RHS = 2 A 2^(n-2) + B (-1)^(n-1) + 
    = 2 A 2^(n-2) + 2 B (-1)^(n-2)
    = A 2^n + B (-1) * n

T(0) = A + B = 1 
T(1) = 2A - B = 1
A = 2/3, B = 1/3
"""


def ti1(n): 
    t = [ 1, 1 ]
    for i in range(2, n+1):
        t.append(t[i-1] + 2 * t[i-2])
    return t[n]

# 동적계획법 
def ti2(n): 
    global dp
    if n == 0 : return 1 
    if n == 1 : return 1 
    if dp[n] != None: return dp[n] 
    dp[n] = ti2(n-1) + 2*ti2(n-2) 
    return dp[n]

# 수학적 방법 
def ti3(n): 
    return (2**(n+1) + (1 if n%2 == 0 else -1))//3

n = int(input("n = "))
print(ti1(n))
dp = [ None ]* (n+1)
print(ti2(n))
print(ti3(n))

```

### 동전 경우의 수 
* 리스트의 뒤에서부터 풀이한다. 
```
""" 
" -------------------------------------------------------------------------------------
"	DP  - 동전 경우의 수 
"   - in algo online class (zoom)
" 	- created at : 2021-07-13 
" -------------------------------------------------------------------------------------
"""
"""
C (K ^2)에 비례한 값이 된다. 
입력예제 
K = 100
1 5 10 

"""
K = int(input("K = "))
coins = list(map(int, input("coins = ").split()))

print(K) 
print(coins)

dp = [0]*(K+1)
dp[0] = 1
for coin in coins: 
    for i in range(K, -1, -1): 
        sum = dp[i]
        for j in range(i-coin, -1, -coin): 
            sum += dp[j]
        dp[i] = sum 

print(dp[K])
```

